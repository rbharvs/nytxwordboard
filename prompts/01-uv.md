# The Ultimate Guide to Modern Python Development with uv

## Introduction: A Better Way for Python Projects

Python development has historically been plagued by frustrating packaging and environment management challenges:

- **Slow dependency resolution** taking minutes to complete
- **Inconsistent lock files** across operating systems
- **Complex setup instructions** for team members
- **Confusing project structures** with unclear conventions

Enter **uv** - an extremely fast Python package installer and resolver written in Rust that resolves these pain points. Similar to `cargo` for Rust or `npm` for Node.js, uv aims to be the single tool you need for Python packaging and development tasks.

### Key Benefits of uv

- **Blazing Speed:** Significantly faster than traditional tools
- **Single Cross-Platform Lockfile:** Works consistently across operating systems
- **Python Version Management:** Automatically downloads and uses required Python versions
- **Standards Compliance:** Builds upon modern Python packaging standards
- **Unified Workflow:** Handles environment creation, dependency installation, and much more

## Part 1: Setting Up a Proper Python Project Structure

### Package vs. Ad-Hoc Structure

When setting up a Python application, you face an important decision:

1. **Ad-Hoc Directory:** Placing `.py` files directly in the project root
   - *Pros:* Simple for trivial projects
   - *Cons:* Fragile imports, potential `PYTHONPATH` manipulation, testing difficulties

2. **Proper Python Package (Recommended):** Structuring code as an installable package with `src/` layout
   - *Pros:*
     - Clearer separation between code and project files
     - Predictable imports
     - Better testability
     - Enables packaging features
     - Works seamlessly with `uv sync`

**This guide recommends the Proper Python Package approach with the `src/` layout.**

### Recommended Project Layout

```
hello-app/
├── .git/           # Version control
├── .gitignore      # Git ignore file
├── pyproject.toml  # Project configuration and dependencies
├── uv.lock         # Locked dependencies (generated by uv)
├── .venv/          # Virtual environment (managed by uv)
├── src/            # Source code root
│   └── hello_svc/  # Your Python package
│       ├── __init__.py
│       ├── asgi.py      # ASGI entry point
│       └── views.py     # Application logic
└── tests/          # Tests
    └── test_e2e.py     # Example test
```

### Creating Your Project

You can initialize a new project with:

```bash
# Create a new project directory
mkdir hello-app
cd hello-app

# Initialize the project
uv init
```

Or for an existing directory:

```bash
cd hello-app
uv init
```

### Entry Points: Defining How to Run Your App

Entry points define how external systems interact with your application. Keep them simple, using them primarily for setup and delegation to your core application code.

Example ASGI entry point (`src/hello_svc/asgi.py`):

```python
# src/hello_svc/asgi.py
from .views import app

# Explicitly export the 'app' object for ASGI servers
__all__ = ["app"]

# In a real app, you might configure logging, Sentry, etc. here
# Example: setup_logging()
# Example: setup_sentry()
# Example: atexit.register(cleanup_resources)
```

## Part 2: Project Configuration with pyproject.toml

The `pyproject.toml` file defines everything about your project for modern packaging tools:

```toml
# pyproject.toml

[project]
# PEP 621 Project Metadata
name = "hello-svc"          # Distribution name
version = "0"               # App version, "0" is fine for internal apps
requires-python = "==3.13.*" # Specify compatible Python versions
dependencies = [            # Runtime dependencies
  "fastapi",
  "granian",                # ASGI server
]

[dependency-groups]
# PEP 735 Dependency Groups (uv supports this!)
# 'dev' group installed automatically in local dev
dev = [
  "fastapi[standard]",      # FastAPI + dev server + extras
  "pytest",                 # Testing framework
]

[build-system]
# PEP 517/518 Build System Definition
requires = ["uv_build>=0.6.6,<0.7"]
build-backend = "uv_build"
```

### Key Sections Explained:

1. **`[project]` (PEP 621):**
   - `name`: The distribution name
   - `version`: Required for packaging (use "0" for internal apps)
   - `requires-python`: Specifies compatible Python versions
   - `dependencies`: Packages needed in production

2. **`[dependency-groups]` (PEP 735):**
   - Modern standard for optional dependency sets
   - The `dev` group is automatically installed during local development

3. **`[build-system]` (PEP 517/518):**
   - Tells tools how to build your package

## Part 3: Managing Dependencies with uv

### Adding Dependencies to Projects

Add dependencies to your project:

```bash
# Add a dependency
uv add requests

# Specify a version constraint
uv add 'requests==2.31.0'

# Add a git dependency
uv add git+https://github.com/psf/requests

# Add dependencies from a requirements file
uv add -r requirements.txt
```

### Removing and Upgrading Dependencies

```bash
# Remove a dependency
uv remove requests

# Upgrade a specific dependency
uv lock --upgrade-package requests
```

### Alternative Package Sources

Install from git repositories:

```bash
# From the main branch
uv add git+https://github.com/owner/repo

# From a specific branch
uv add git+https://github.com/owner/repo@branch-name

# From a specific tag or commit
uv add git+https://github.com/owner/repo@v1.2.3
uv add git+https://github.com/owner/repo@abc123
```

Use an alternative package index:

```bash
uv add --index "https://example.com/simple" 'requests<3'
```

### Cross-Platform Lockfiles

uv generates cross-platform lockfiles (`uv.lock`) that ensure consistent environments:

```bash
# Generate or update the lockfile
uv lock
```

## Part 4: Zero-Setup Local Development with uv run

The real magic of uv is how it simplifies local development with zero manual environment setup (beyond installing uv itself).

### Running Your Application or Tests

```bash
# Run your tests
uv run pytest

# Run a development server
uv run fastapi dev src/hello_svc/asgi.py

# Run with production server directly
uv run granian --port 8000 src/hello_svc.asgi:app
```

### What Happens with uv run?

When you run `uv run`:

1. **Python Check:** Verifies a suitable Python version is available
2. **Virtual Env:** Creates/updates `.venv` as needed
3. **Lock File:** Creates/uses `uv.lock` to resolve dependencies
4. **Sync:** Updates the environment based on `pyproject.toml` and `uv.lock`
5. **Execute:** Runs your command within the managed environment

### Benefits:

- **Consistency:** Everyone gets the exact same dependencies
- **Simplicity:** New developers just need `uv`, clone the repo, and run commands
- **Speed:** Environment creation and syncing are incredibly fast
- **Cross-Platform:** The same `uv.lock` works on different OSes

Remember to add `.venv` to your `.gitignore` file!

## Part 5: Working with Scripts and Inline Metadata

For simpler scripts that aren't part of a full package, uv supports inline metadata:

### Creating Scripts with Dependencies

```bash
# Create a new script with inline metadata
uv init --script example.py --python 3.12
```

### Declaring Dependencies for Scripts

```bash
# Add dependencies to a script
uv add --script example.py 'requests<3' 'rich'
```

This adds a `script` section at the top of your file:

```python
# /// script
# dependencies = [\
#   "requests<3",\
#   "rich",\
# ]
# ///

import requests
from rich.pretty import pprint

# Your code here
```

### Running Scripts with Dependencies

```bash
# Run with declared dependencies
uv run example.py

# Or specify dependencies on the fly
uv run --with requests --with 'rich>12,<13' example.py
```

### Locking Script Dependencies

```bash
uv lock --script example.py
```

This creates a `.lock` file (e.g., `example.py.lock`) for reproducible execution.

## Part 6: Managing and Running Tools

### Running Tools Without Installation

The `uvx` command runs tools without installing them:

```bash
# Run ruff
uvx ruff check .

# If package name differs from command
uvx --from httpie http

# With specific version
uvx ruff@0.3.0 check

# With extras
uvx --from 'mypy[faster-cache,reports]' mypy --xml-report mypy_report

# With additional dependencies
uvx --with mkdocs-material mkdocs --help
```

### Installing Tools Persistently

```bash
# Install a tool permanently
uv tool install ruff

# After installation, use directly
ruff --version

# With version constraint
uv tool install 'httpie>0.1.0'

# With additional packages
uv tool install mkdocs --with mkdocs-material
```

### Upgrading Installed Tools

```bash
# Upgrade a specific tool
uv tool upgrade ruff

# Upgrade all tools
uv tool upgrade --all
```

### Specifying Python Versions for Tools

```bash
# When running
uvx --python 3.10 ruff

# When installing
uv tool install --python 3.10 ruff
```

## Part 7: Advanced Usage and Commands

### Using Different Python Versions

Specify a Python version for execution:

```bash
uv run --python 3.10 example.py
```

### Building Project Distributions

Build source and wheel distributions:

```bash
uv build
```

This creates both `.tar.gz` and `.whl` files in the `dist/` directory.

### Running Commands in Project Context

```bash
# Run a command in your project environment
uv run -- flask run -p 3000

# Or sync and activate manually
uv sync
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
flask run -p 3000
```

### Improving Reproducibility

Limit uv to only consider distributions released before a specific date:

```python
# /// script
# dependencies = [\
#   "requests",\
# ]
# [tool.uv]
# exclude-newer = "2023-10-16T00:00:00Z"
# ///
```

Or in `pyproject.toml`:

```toml
[tool.uv]
exclude-newer = "2023-10-16T00:00:00Z"
```

## Conclusion

Using `uv` transforms Python project management from a source of frustration into a streamlined, fast, and reliable process. The proper package structure (`src/` layout) combined with modern tools makes it easy to develop locally and scale to production.

By leveraging uv's modern interfaces, you get:

- **Proper project structure** that scales well
- **Fast dependency management** with cross-platform lockfiles
- **Zero-setup local development** for your team
- **Simplified tool management** without version conflicts
- **Standards-based configuration** using modern Python PEPs

Whether you're building a simple script or a complex application, `uv` provides the tools to make Python development more enjoyable and efficient.
